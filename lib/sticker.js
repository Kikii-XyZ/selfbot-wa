const moment = require("moment-timezone");const cheerio = require("cheerio");const mime = require('mime-types');const fs = require('fs-extra')const ffmpeg = require('fluent-ffmpeg')const process = require('process');const request = require('request')const sharp = require('sharp')const { Readable, Writable } = require('stream')const imageToBase64 = require('image-to-base64');const get = require('got')const fetch = require('node-fetch');const urlencode = require("urlencode");const axios = require("axios").defaultconst syntaxerror = require('syntax-error')const path = require('path')const util = require('util')const figlet = require('figlet');const { spawn, exec, execSync } = require("child_process");const convertSticker = function(shape, author, pack, mediaData, type) {  return new Promise((resolve, reject) => {    var upfile = "sticker." + type;    var metadata = {      "pack": pack,      "author": author,      "shape": shape,      "api_key": "JDJiJDEwJGdmVUtWUHk4eldkYlBhcUJZLklRMHV2eHVUc2Z1M1hrOVZSN1N6eWZFeEN0aWloOUpNT2RX",    };    var url = "https://stickerman.org/api/convert";    var boundary = "sticker";    let data = "";    for (var i in metadata) {      if ({}.hasOwnProperty.call(metadata, i)) {        data += "--" + boundary + "\r\n";        data += "Content-Disposition: form-data; name=" + i + "; \r\n\r\n" + metadata[i] + "\r\n";      }    };    data += "--" + boundary + "\r\n";    data += "Content-Disposition: form-data; name=sticker; filename=" + upfile + "\r\n";    data += "Content-Type:application/octet-stream\r\n\r\n";    var payload = Buffer.concat([      Buffer.from(data, "utf8"),      new Buffer(mediaData, 'binary'),      Buffer.from("\r\n--" + boundary + "--\r\n", "utf8"),    ]);    var options = {      method: 'post',      url: url,      headers: {        "Content-Type": "multipart/form-data; boundary=" + boundary      },      body: payload,      encoding: null    };    request(options, function(error, response, body) {      if (error) {        reject(error)      } else {        resolve(body)      }    });  });};const stickerPackID = "com.snowcorp.stickerly.android.stickercontentprovider b5e7275f-f1de-4137-961f-57becfad34f2";const googleLink = "https://play.google.com/store/apps/details?id=com.marsconstd.stickermakerforwhatsapp";const appleLink = "https://itunes.apple.com/app/sticker-maker-studio/id1443326857";function sleep(ms) {  return new Promise(resolve => setTimeout(resolve, ms));}async function createExif(packname, author) {  const json = {    "sticker-pack-id": stickerPackID,    "sticker-pack-name": packname,    "sticker-pack-publisher": author,    "android-app-store-link": googleLink,    "ios-app-store-link": appleLink  };  let length = JSON.stringify(json).length;  const f = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00]);  const code = [    0x00,    0x00,    0x16,    0x00,    0x00,    0x00  ];  if (length > 256) {    length = length - 256;    code.unshift(0x01);  } else {    code.unshift(0x00);  }  const fff = Buffer.from(code);  const ffff = Buffer.from(JSON.stringify(json));  if (length < 16) {    length = length.toString(16);    length = "0" + length;  } else {    length = length.toString(16);  }  const ff = Buffer.from(length, "hex");  const buffer = Buffer.concat([f, ff, fff, ffff]);  await fs.writeFileSync('./image/p.exif', buffer, function(err) {    if (err) return console.error(err);  });}function modifExif(buffer, id, callback) {  fs.writeFileSync('./image/' + id + '.webp', buffer)  spawn('webpmux', ['-set', 'exif', './image/p.exif', './image/' + id + '.webp', '-o', './image/' + id + '.webp'])    .on('exit', () => {      callback(fs.readFileSync('./image/' + id + '.webp'))      fs.unlink('./image/' + id + '.webp').then(() => {})    })}function bufferToStream(buffer) {  const readable = new Readable()  readable._read = () => {}  readable.push(buffer)  readable.push(null)  return readable}const modifWebp = (id, buffers) => new Promise((resolve) => {  const stream = bufferToStream(buffers)  ffmpeg(stream)  .inputFormat('mp4')  .addOutputOptions("-vcodec", "libwebp", "-vf", "scale='min(150,iw)':min'(150,ih)':force_original_aspect_ratio=decrease, format=rgba, fps=15, pad=150:150:-1:-1:color=#00000000", '-lossless', '1', "-loop", "1", "-preset", "default", "-an", "-vsync", "0", "-s", "150:150")  .save(`./image/${id}.webp`)  .on('end', () => {    stream.destroy()    spawn('webpmux', ['-set', 'exif', './image/p.exif', './image/' + id + '.webp', '-o', './image/' + id + '.webp'])    .on('exit', () => {      let mediaData = (fs.readFileSync('./image/' + id + '.webp'))      fs.unlink('./image/' + id + '.webp').then(() => {})      return resolve(mediaData)    })  })})exports.convertSticker = convertStickerexports.sleep = sleepexports.createExif = createExifexports.modifExif = modifExifexports.bufferToStream = bufferToStreamexports.modifWebp = modifWebp